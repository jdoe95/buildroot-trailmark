// SPDX-License-Identifier: GPL-2.0-only
/*
 * Copyright (C) 2021 Mestek Inc
 */
#include <dt-bindings/leds/common.h>

/*
 * Documentation/devicetree/bindings/pinctrl/pinctrl-single.txt
 * Pin configurations are generated by Texas Instrument's online SysConfig tool.
 */
&am33xx_pinmux {
	
	/* I2C0 pins (for PMIC and onboard EEPROM) */
	i2c0_pins: i2c0_pins {
		pinctrl-single,pins = <
			AM33XX_IOPAD(0x98c, PIN_INPUT | MUX_MODE0) /* (C16) I2C0_SCL.I2C0_SCL */
			AM33XX_IOPAD(0x988, PIN_INPUT | MUX_MODE0) /* (C17) I2C0_SDA.I2C0_SDA */
		>;
	};

	/* I2C1 pins */
	i2c1_pins: i2c1_pins {
		pinctrl-single,pins = <
			AM33XX_IOPAD(0x95c, PIN_INPUT | MUX_MODE2) /* (A16) spi0_cs0.I2C1_SCL */
			AM33XX_IOPAD(0x958, PIN_INPUT | MUX_MODE2) /* (B16) spi0_d1.I2C1_SDA */
		>;
	};

	/* I2C2 pins */
	i2c2_pins: i2c2_pins {
		pinctrl-single,pins = <
			AM33XX_IOPAD(0x97c, PIN_INPUT | MUX_MODE3) /* (D17) uart1_rtsn.I2C2_SCL */
			AM33XX_IOPAD(0x978, PIN_INPUT | MUX_MODE3) /* (D18) uart1_ctsn.I2C2_SDA */
		>;
	};

	/* LED pins */
	led_pins: led_pins {
		pinctrl-single,pins = <
			AM33XX_IOPAD(0x854, PIN_OUTPUT | MUX_MODE7) /* (V15) gpmc_a5.gpio1[21] */
			AM33XX_IOPAD(0x858, PIN_OUTPUT | MUX_MODE7) /* (U15) gpmc_a6.gpio1[22] */
			AM33XX_IOPAD(0x85c, PIN_OUTPUT | MUX_MODE7) /* (T15) gpmc_a7.gpio1[23] */
			AM33XX_IOPAD(0x860, PIN_OUTPUT | MUX_MODE7) /* (V16) gpmc_a8.gpio1[24] */
		>;
	};

	/* UART0 pins (for serial debug console) */
	uart0_pins: uart0_pins {
		pinctrl-single,pins = <
			AM33XX_IOPAD(0x970, PIN_INPUT_PULLUP | MUX_MODE0) /* (E15) uart0_rxd.uart0_rxd */
			AM33XX_IOPAD(0x974, PIN_OUTPUT | MUX_MODE0) /* (E16) uart0_txd.uart0_txd */
		>;
	};

	/* UART2 pins (for RS-485 connection) */
	uart2_pins: uart2_pins {
		pinctrl-single,pins = <
			AM33XX_IOPAD(0x950, PIN_INPUT_PULLUP | MUX_MODE1) /* (A17) spi0_sclk.uart2_rxd */
			AM33XX_IOPAD(0x954, PIN_OUTPUT | MUX_MODE1) /* (B17) spi0_d0.uart2_txd */
		>;
	};

	/* UART4 pins */
	uart4_pins: uart4_pins {
		pinctrl-single,pins = <
			AM33XX_IOPAD(0x870, PIN_INPUT_PULLUP | MUX_MODE6) /* (T17) gpmc_wait0.uart4_rxd */
			AM33XX_IOPAD(0x874, PIN_OUTPUT | MUX_MODE6) /* (U17) gpmc_wpn.uart4_txd */
		>;
	};

	/* MMC1 (external SDCard) pins */
	mmc1_pins: mmc1_pins {
		pinctrl-single,pins = <
			AM33XX_IOPAD(0x900, PIN_INPUT | MUX_MODE0) /* (G17) mmc0_clk.mmc1_clk */
			AM33XX_IOPAD(0x904, PIN_INPUT | MUX_MODE0) /* (G18) mmc0_cmd.mmc1_cmd */
			AM33XX_IOPAD(0x8fc, PIN_INPUT | MUX_MODE0) /* (G16) mmc0_dat0.mmc1_dat0 */
			AM33XX_IOPAD(0x8f8, PIN_INPUT | MUX_MODE0) /* (G15) mmc0_dat1.mmc1_dat1 */
			AM33XX_IOPAD(0x8f4, PIN_INPUT | MUX_MODE0) /* (F18) mmc0_dat2.mmc1_dat2 */
			AM33XX_IOPAD(0x8f0, PIN_INPUT | MUX_MODE0) /* (F17) mmc0_dat3.mmc1_dat3 */
			AM33XX_IOPAD(0x960, PIN_INPUT | MUX_MODE7) /* (C15) spi0_cs1.mmc1_sdcd */
		>;
	};
	
	/* MMC2 (on-board eMMC) pins */
	mmc2_pins: mmc2_pins {
		pinctrl-single,pins = <
			/* eMMC RESET# */
			//AM33XX_IOPAD(0x850, PIN_OUTPUT_PULLUP | MUX_MODE2) /* (R14) gpmc_a4.gpio1[20] */
			
			AM33XX_IOPAD(0x880, PIN_INPUT | MUX_MODE2) /* (U9) gpmc_csn1.mmc2_clk */
			AM33XX_IOPAD(0x884, PIN_INPUT | MUX_MODE2) /* (V9) gpmc_csn2.mmc2_cmd */
			AM33XX_IOPAD(0x800, PIN_INPUT | MUX_MODE1) /* (U7) gpmc_ad0.mmc2_dat0 */
			AM33XX_IOPAD(0x804, PIN_INPUT | MUX_MODE1) /* (V7) gpmc_ad1.mmc2_dat1 */
			AM33XX_IOPAD(0x808, PIN_INPUT | MUX_MODE1) /* (R8) gpmc_ad2.mmc2_dat2 */
			AM33XX_IOPAD(0x80c, PIN_INPUT | MUX_MODE1) /* (T8) gpmc_ad3.mmc2_dat3 */
			AM33XX_IOPAD(0x810, PIN_INPUT | MUX_MODE1) /* (U8) gpmc_ad4.mmc2_dat4 */
			AM33XX_IOPAD(0x814, PIN_INPUT | MUX_MODE1) /* (V8) gpmc_ad5.mmc2_dat5 */
			AM33XX_IOPAD(0x818, PIN_INPUT | MUX_MODE1) /* (R9) gpmc_ad6.mmc2_dat6 */
			AM33XX_IOPAD(0x81c, PIN_INPUT | MUX_MODE1) /* (T9) gpmc_ad7.mmc2_dat7 */
		>;
	};
	
	/* MDIO pins (for configuring the Ethernet PHY) */
	mdio_pins: mdio_pins {
		pinctrl-single,pins = <
			AM33XX_IOPAD(0x94c, PIN_OUTPUT_PULLUP | MUX_MODE0) /* (M18) mdio_clk.mdio_clk */
			AM33XX_IOPAD(0x948, PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE0) /* (M17) mdio_data.mdio_data */
		>;
	};
	
	/* MII1 pins (for connecting to the Ethernet PHY) */
	cpsw_pins: cpsw_pins {
		pinctrl-single,pins = <
			AM33XX_IOPAD(0x908, PIN_INPUT_PULLDOWN | MUX_MODE0) /* (H16) gmii1_col.gmii1_col */
			AM33XX_IOPAD(0x90c, PIN_INPUT_PULLDOWN | MUX_MODE0) /* (H17) gmii1_crs.gmii1_crs */
			AM33XX_IOPAD(0x910, PIN_INPUT_PULLUP | MUX_MODE0) /* (J15) gmii1_rxer.gmii1_rxer */
			AM33XX_IOPAD(0x914, PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* (J16) gmii1_txen.gmii1_txen */
			AM33XX_IOPAD(0x918, PIN_INPUT_PULLUP | MUX_MODE0) /* (J17) gmii1_rxdv.gmii1_rxdv */
			AM33XX_IOPAD(0x92c, PIN_INPUT_PULLUP | MUX_MODE0) /* (K18) gmii1_txclk.gmii1_txclk */
			AM33XX_IOPAD(0x930, PIN_INPUT_PULLUP | MUX_MODE0) /* (L18) gmii1_rxclk.gmii1_rxclk */
			AM33XX_IOPAD(0x928, PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* (K17) gmii1_txd0.gmii1_txd0 */
			AM33XX_IOPAD(0x924, PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* (K16) gmii1_txd1.gmii1_txd1 */
			AM33XX_IOPAD(0x920, PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* (K15) gmii1_txd2.gmii1_txd2 */
			AM33XX_IOPAD(0x91c, PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* (J18) gmii1_txd3.gmii1_txd3 */
			AM33XX_IOPAD(0x940, PIN_INPUT_PULLUP | MUX_MODE0) /* (M16) gmii1_rxd0.gmii1_rxd0 */
			AM33XX_IOPAD(0x93c, PIN_INPUT_PULLUP | MUX_MODE0) /* (L15) gmii1_rxd1.gmii1_rxd1 */
			AM33XX_IOPAD(0x938, PIN_INPUT_PULLUP | MUX_MODE0) /* (L16) gmii1_rxd2.gmii1_rxd2 */
			AM33XX_IOPAD(0x934, PIN_INPUT_PULLUP | MUX_MODE0) /* (L17) gmii1_rxd3.gmii1_rxd3 */
		>;
	};
	
	/* LCD controller pins */
	lcdc_pins: lcdc_pins {
		pinctrl-single,pins = <
			AM33XX_IOPAD(0x8e0, PIN_OUTPUT | MUX_MODE0) /* (U5) lcd_vsync.lcd_vsync */
			AM33XX_IOPAD(0x8e4, PIN_OUTPUT | MUX_MODE0) /* (R5) lcd_hsync.lcd_hsync */
			AM33XX_IOPAD(0x8e8, PIN_OUTPUT | MUX_MODE0) /* (V5) lcd_pclk.lcd_pclk */
			AM33XX_IOPAD(0x8ec, PIN_OUTPUT | MUX_MODE0) /* (R6) lcd_ac_bias_en.lcd_ac_bias_en */
			/* The LCD data pins are connected to SYSBOOT boot mode pull-up/down resistors */
			AM33XX_IOPAD(0x8a0, PIN_OUTPUT | MUX_MODE0) /* (R1) lcd_data0.lcd_data0 */
			AM33XX_IOPAD(0x8a4, PIN_OUTPUT | MUX_MODE0) /* (R2) lcd_data1.lcd_data1 */
			AM33XX_IOPAD(0x8a8, PIN_OUTPUT | MUX_MODE0) /* (R3) lcd_data2.lcd_data2 */
			AM33XX_IOPAD(0x8ac, PIN_OUTPUT | MUX_MODE0) /* (R4) lcd_data3.lcd_data3 */
			AM33XX_IOPAD(0x8b0, PIN_OUTPUT | MUX_MODE0) /* (T1) lcd_data4.lcd_data4 */
			AM33XX_IOPAD(0x8b4, PIN_OUTPUT | MUX_MODE0) /* (T2) lcd_data5.lcd_data5 */
			AM33XX_IOPAD(0x8b8, PIN_OUTPUT | MUX_MODE0) /* (T3) lcd_data6.lcd_data6 */
			AM33XX_IOPAD(0x8bc, PIN_OUTPUT | MUX_MODE0) /* (T4) lcd_data7.lcd_data7 */
			AM33XX_IOPAD(0x8c0, PIN_OUTPUT | MUX_MODE0) /* (U1) lcd_data8.lcd_data8 */
			AM33XX_IOPAD(0x8c4, PIN_OUTPUT | MUX_MODE0) /* (U2) lcd_data9.lcd_data9 */
			AM33XX_IOPAD(0x8c8, PIN_OUTPUT | MUX_MODE0) /* (U3) lcd_data10.lcd_data10 */
			AM33XX_IOPAD(0x8cc, PIN_OUTPUT | MUX_MODE0) /* (U4) lcd_data11.lcd_data11 */
			AM33XX_IOPAD(0x8d0, PIN_OUTPUT | MUX_MODE0) /* (V2) lcd_data12.lcd_data12 */
			AM33XX_IOPAD(0x8d4, PIN_OUTPUT | MUX_MODE0) /* (V3) lcd_data13.lcd_data13 */
			AM33XX_IOPAD(0x8d8, PIN_OUTPUT | MUX_MODE0) /* (V4) lcd_data14.lcd_data14 */
			AM33XX_IOPAD(0x8dc, PIN_OUTPUT | MUX_MODE0) /* (T5) lcd_data15.lcd_data15 */
		>;
	};
	
	/* EHRPWM1 pins (LCD backlight) */
	ehrpwm1_pins: ehrpwm1_pins {
		pinctrl-single,pins = <
			AM33XX_IOPAD(0x848, PIN_OUTPUT | MUX_MODE6) /* (U14) gpmc_a2.ehrpwm1A */
		>;
	};
};



/ {
	cpus {
		cpu@0 {
			cpu0-supply = <&dcdc2_reg>;
		};
	};

	memory@80000000 {
		device_type = "memory";
		reg = <0x80000000 0x20000000>; /* 512MB */
	};

	/*
	 * Documentation/devicetree/bindings/leds/leds-gpio.txt
	 * Documentation/devicetree/bindings/gpio/gpio.txt
	 */
	leds {
		compatible = "gpio-leds";

		pinctrl-names = "default";
		pinctrl-0 = <&led_pins>;

		led0 {
			function = LED_FUNCTION_CPU;
			color = <LED_COLOR_ID_BLUE>;
			linux,default-trigger = "cpu";
			gpios = <&gpio1 21 GPIO_ACTIVE_HIGH>;
		};

		led1 {
			function = LED_FUNCTION_DISK_ACTIVITY;
			color = <LED_COLOR_ID_BLUE>;
			linux,default-trigger = "disk-activity";
			gpios = <&gpio1 22 GPIO_ACTIVE_HIGH>;
		};

		led2 {
			function = LED_FUNCTION_USB;
			color = <LED_COLOR_ID_BLUE>;
			linux,default-trigger= "usbport";
			gpios = <&gpio1 23 GPIO_ACTIVE_HIGH>;
		};

		led3 {
			function = LED_FUNCTION_PANIC;
			color = <LED_COLOR_ID_RED>;
			linux,default-trigger = "panic";
			gpios = <&gpio1 24 GPIO_ACTIVE_HIGH>;
		};
	};

	/*
	 * Documentation/devicetree/bindings/regulator/regulator.yaml
	 */
	onboard_regulator: fixedregulator {
		compatible = "regulator-fixed";
		regulator-name = "vdd_3v3b";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
	};
	
	backlight_regulator: fixedregulator {
		compatible = "regulator-fixed";
		regulator-name = "backlight_regulator";
		regulator-always-on;
		regulator-boot-on;
	};

	/*
	 * Documentation/devicetree/bindings/leds/backlight/pwm-backlight.yaml
	 * Documentation/devicetree/bindings/pwm/pwm.txt
	 * Documentation/devicetree/bindings/pwm/pwm.yaml
	 */
	backlight: backlight {
		status = "okay";
		compatible = "pwm-backlight";
		power-supply = <&backlight_regulator>;
	};

	lcd_panel: lcd_panel {
		status = "okay";
		compatible = "ti,tilcdc,panel";
		pinctrl-names = "default";
		pinctrl-0 = <&lcdc_pins>;
	};
};



/*
 * Documentation/devicetree/bindings/serial/rs485.yaml
 * Documentation/devicetree/bindings/serial/serial.yaml
 */
&uart0 {
	pinctrl-names = "default";
	pinctrl-0 = <&uart0_pins>;
	status = "okay";
};

&uart2 {
	pinctrl-names = "default";
	pinctrl-0 = <&uart2_pins>;

	/*
	 * The RTS signal is software-controlled by the Linux kernel. It is usually
	 * connected to the transmitter enable pin of the RS-485 transceiver.
	 * TODO
	 */
	rts-gpios = <&gpio0 12 GPIO_ACTIVE_HIGH>;

	/* add 1ms delay before and after asserting/deasserting RTS signal */
	rs485-rts-delay = <1 1>;

	/*
	 * Ask kernel to enable RT-485 mode at boot time. Otherwise software needs
	 * to use ioctl() to switch the serial port into RS-485 mode.
	 */
	linux,rs485-enabled-at-boot-time;
};

&uart4 {
	pinctrl-names = "default";
	pinctrl-0 = <&uart4_pins>;
};



/*
 * Documentation/devicetree/bindings/i2c/i2c-omap.txt
 */
&i2c0 {
	pinctrl-names = "default";
	pinctrl-0 = <&i2c0_pins>;
	status = "okay";

	// 400 kHz
	clock-frequency = <400000>;

	/* TPS65217 PMIC at I2C0 address 0x24 */
	tps: tps@24 {
		reg = <0x24>;
	};

	/* Factory EEPROM at I2C0 address 0x50 */
	onboard_eeprom: onboard_eeprom@50 {
		reg = <0x50>;
	};
};

&i2c1 {
	pinctrl-names = "default";
	pinctrl-0 = <&i2c1_pins>;
};

&i2c2 {
	pinctrl-names = "default";
	pinctrl-0 = <&i2c2_pins>;
};



/*
 * Documentation/devicetree/bindings/eeprom/at24.yaml
 */
&onboard_eeprom {
	compatible = "atmel,24c32";
	vcc-supply = <&onboard_regulator>;
	page-size = <32>;  /* 32-byte EEPROM page size, see datasheet */
	size = <4096>;  /* 4096 bytes total storage, see datasheet */
	address-width = <16>; /* 16-bit EEPROM address */

	#address-cells = <1>;
	#size-cells = <1>;
	factory_data: factory_data@0 {
		reg = <0 0x100>;
	};
};



/*
 * Documentation/devicetree/bindings/mmc/ti-omap-hsmmc.txt
 * Documentation/devicetree/bindings/mmc/mmc.txt
 * MMC1 is the SDCard. MMC2 is the on-board eMMC.
 * Labels always reference node names mmc1 mmc2 mmc3 and not their
 * aliases mmc0 mmc1 mmc2.
 */
&mmc1 {
	pinctrl-names = "default";
	pinctrl-0 = <&mmc1_pins>;
	
	vmmc-supply = <&onboard_regulator>;
	vqmmc-supply = <&onboard_regulator>;
	bus-width = <4>;	
	
	cd-gpios = <&gpio0 6 GPIO_ACTIVE_LOW>;
	
	status = "okay";
};

&mmc2 {
	pinctrl-names = "default";
	pinctrl-0 = <&mmc2_pins>;
	
	non-removable;
	vmmc-supply = <&onboard_regulator>;
	vqmmc-supply = <&onboard_regulator>;
	bus-width = <8>;
	
	status = "okay";
};



/*
 * Documentation/devicetree/bindings/net/davinci-mdio.txt
 * Documentation/devicetree/bindings/net/cpsw.txt
 * Documentation/devicetree/bindings/net/ethernet-controller.yaml
 */
&davinci_mdio {
	pinctrl-names = "default";
	pinctrl-0 = <&mdio_pins>;
	bus_freq = <1000000>;
	status = "okay";
};

&mac {
	pinctrl-names = "default";
	pinctrl-0 = <&cpsw_pins>;
	slaves = <1>;
	status = "okay";
};

&cpsw_emac0 {
	phy_id = <&davinci_mdio 0>;
	phy-mode = "mii";
	status = "okay";
};



/*
 * Documentation/devicetree/bindings/rtc/rtc-omap.txt
 */
&rtc {
	clocks = <&clk_32768_ck>, <&clk_24mhz_clkctrl AM3_CLKDIV32K_CLKCTRL 0>;
	clock-names = "ext-clk", "int-clk";
	system-power-controller;
};



/*
 * For LCD backlight
 * Documentation/devicetree/bindings/pwm/pwm-tipwmss.txt
 * Documentation/devicetree/bindings/pwm/pwm-tiehrpwm.txt
 */
&epwmss1 {
	status = "okay";
};

&ehrpwm1 {
	pinctrl-names = "default";
	pinctrl-0 = <&ehrpwm1_pins>;
	status = "okay";
};

/*
 * Documentation/devicetree/bindings/display/tilcdc/tilcdc.txt
 */
&lcdc {
	// AM335x errata (see documentation)
//	blue-and-red-wiring = "straight";
	status = "okay";
};

/*
 * For resistive touchscreen
 * Documentation/devicetree/bindings/input/touchscreen/ti-tsc-adc.txt
 */
&tscadc {

	tsc {
		ti,wires = <4>;
		// see WJ70A2TIAGDNT0 display panel datasheet
		ti,x-plate-resistance = <670>;
		ti,coordiate-readouts = <5>;
		ti,wire-config = <0x00 0x11 0x22 0x33>;
	};

	adc {
		ti,adc-channels = <4 5 6 7>;
	};
};

/*
 * Documentation/devicetree/bindings/leds/backlight/pwm-backlight.txt
 */
&backlight {
	pwms = <&ehrpwm1 0 1000000 0>;
	brightness-levels = <0 100>;
	num-interpolated-steps = <10>;
	default-brightness-level = <1>;
};

/*
 * Documentation/devicetree/bindings/display/tilcdc/panel.txt
 */
&lcd_panel {
	panel-info {
		ac-bias           = <255>;
		ac-bias-intrpt    = <0>;
		dma-burst-sz      = <16>;
		bpp               = <16>;
		fdd               = <0x80>;
		sync-edge         = <0>;
		sync-ctrl         = <1>;
		raster-order      = <0>;
		fifo-th           = <0>;
	};

	/*
	 * See WJ70A2TIAGDNT0# LCD panel datasheet for timing
	 * Documentation/devicetree/bindings/display/panel/display-timings.yaml
	 */
	display-timings {
		native-mode = <&timing0>;

		timing0: WJ70A2TIAGDNT0_800X480 {
			clock-frequency = <40000000>;
			de-active       = <1>;

			// driven on rising edge, sampled on falling edge
			pixelclk-active = <1>;

			// driven on rising edge, sampled on falling edge
			syncclk-active  = <1>;

			hactive         = <800>;
			vactive         = <480>;

			hback-porch     = <46 46 46>;
			hfront-porch    = <16 210 354>;
			hsync-len       = <1 1 40>;
			hsync-active    = <0>;

			vback-porch     = <23 23 23>;
			vfront-porch    = <7 22 147>;
			vsync-len       = <1 1 20>;
			vsync-active    = <0>;
		};
	};
};



/*
 * Documentation/devicetree/bindings/usb/am33xx-usb.txt
 */
&usb {
	status = "okay";
};

&cppi41dma {
	status = "okay";
};

&usb_ctrl_mod {
	status = "okay";
};

&usb0_phy {
	status = "okay";
};

&usb0 {
	dr_mode = "otg";
	status = "okay";
	interrupts-extended = <&intc 18 &tps 0>;
	interrupt-names = "mc", "vbus";
};

&usb1_phy {
	status = "okay";
};

&usb1 {
	dr_mode = "host";
	status = "okay";
};



/* Overriding node in current file */
/include/ "tps65217.dtsi"
&tps {
	/*
	 * Configure pmic to enter OFF-state instead of SLEEP-state ("RTC-only
	 * mode") at poweroff.  Most BeagleBone versions do not support RTC-only
	 * mode and risk hardware damage if this mode is entered.
	 *
	 * For details, see linux-omap mailing list May 2015 thread
	 *	[PATCH] ARM: dts: am335x-bone* enable pmic-shutdown-controller
	 * In particular, messages:
	 *	http://www.spinics.net/lists/linux-omap/msg118585.html
	 *	http://www.spinics.net/lists/linux-omap/msg118615.html
	 *
	 * You can override this later with
	 *	&tps {  /delete-property/ ti,pmic-shutdown-controller;  }
	 * if you want to use RTC-only mode and made sure you are not affected
	 * by the hardware problems. (Tip: double-check by performing a current
	 * measurement after shutdown: it should be less than 1 mA.)
	 */

	interrupts = <7>; /* NMI */
	interrupt-parent = <&intc>;

	ti,pmic-shutdown-controller;
	
	pwrbutton {
		status = "okay";
	};

	charger {
		status = "okay";
	};

	regulators {
		dcdc1_reg: regulator@0 {
			regulator-name = "vdds_dpr";
			regulator-always-on;
		};

		dcdc2_reg: regulator@1 {
			/* VDD_MPU voltage limits 0.95V - 1.26V with +/-4% tolerance */
			regulator-name = "vdd_mpu";
			regulator-min-microvolt = <925000>;
			regulator-max-microvolt = <1351500>;
			regulator-boot-on;
			regulator-always-on;
		};

		dcdc3_reg: regulator@2 {
			/* VDD_CORE voltage limits 0.95V - 1.1V with +/-4% tolerance */
			regulator-name = "vdd_core";
			regulator-min-microvolt = <925000>;
			regulator-max-microvolt = <1150000>;
			regulator-boot-on;
			regulator-always-on;
		};

		ldo1_reg: regulator@3 {
			regulator-name = "vio,vrtc,vdds";
			regulator-always-on;
		};

		ldo2_reg: regulator@4 {
			regulator-name = "vdd_3v3aux";
			regulator-always-on;
		};

		ldo3_reg: regulator@5 {
			regulator-name = "vdd_1v8";
			regulator-always-on;
		};

		ldo4_reg: regulator@6 {
			regulator-name = "vdd_3v3a";
			regulator-always-on;
		};
	};
};

